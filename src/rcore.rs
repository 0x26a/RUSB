use crate::rhandler::RusbError::*;use crate::rcore;use crate::rgraphics;use core::ffi::c_void;use uefi_raw::table::system::SystemTable;use uefi::prelude::*;use uefi::boot::*;use log::info;use uefi::{guid, Guid};use uefi::proto::device_path::DevicePath;use uefi::proto::media::fs::SimpleFileSystem;use uefi::Identify;use uefi::proto::media::file::File;use uefi::proto::media::file::FileMode::Read;use uefi::proto::media::file::FileAttribute;use embedded_graphics::mono_font::MonoFont;use uefi_graphics2::UefiDisplay;pub struct Rusb<'a>{    pub im_handle: Handle,    pub system_table: &'a SystemTable,    pub uefi_display: UefiDisplay,    pub font: MonoFont<'a>,    pub line: i32}impl Rusb<'_>{    pub unsafe fn new<'a>(system_table: &'a SystemTable, font: MonoFont<'static>) -> Rusb<'a>{        let uefi_display = Rusb::get_uefi_display(system_table);        return Rusb{            im_handle: image_handle(),            system_table: system_table,            uefi_display: uefi_display,            font: font,            line: 50        };    }    pub unsafe fn close_protocol(&mut self, handle: Handle){        let to_close = [SimpleFileSystem::GUID, DevicePath::GUID];        for guid in to_close{            let status = ((*self.system_table.boot_services).close_protocol)(                handle.as_ptr(),                &guid as *const Guid,                self.im_handle.as_ptr(),                0 as *mut c_void            );            self.write(&format!("closed {} : {:?}", guid, status));        }    }    pub unsafe fn read_file_from_path(&mut self, file_path:&str, mut dir: uefi::proto::media::file::Directory, buffer: &mut [u8]){        let mut file_path_buffer: [u16;30] = [0;30];        let file_path_u16 = uefi::data_types::CStr16::from_str_with_buf(file_path, &mut file_path_buffer).unwrap();        match dir.open(file_path_u16,Read,FileAttribute::READ_ONLY){            Ok(file_handle) => {                match file_handle.into_regular_file(){                    Some(mut regular_file) => {                        regular_file.read(buffer).expect("error: couldn't read file");                        regular_file.close()                    },                    _ => self.handle(NotRegular)                }            },            Err(e) => self.handle(OpenFileError(e))        }    }}